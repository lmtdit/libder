// Generated by CoffeeScript 1.9.3
var Tools, _, _modName, _paths, build, color, fs, gulp, gutil, jsCtl, less, mincss, path, pkg, plumber, server, setting, watch,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

_ = require('lodash');

gulp = require('gulp');

gutil = require('gulp-util');

less = require('gulp-less');

mincss = require('gulp-minify-css');

plumber = require('gulp-plumber');

watch = require('gulp-watch');

server = require('gulp-server-livereload');

setting = require('./setting');

color = gutil.colors;

pkg = require('../package.json');

_modName = pkg.name;


/*
 * base functions
 */

Tools = {
  md5: function(text) {
    return crypto.createHash('md5').update(text).digest('hex');
  },
  mkdirsSync: function(dirpath, mode) {
    if (fs.existsSync(dirpath)) {
      return true;
    } else {
      if (Tools.mkdirsSync(path.dirname(dirpath), mode)) {
        fs.mkdirSync(dirpath, mode);
        return true;
      }
    }
  },
  errHandler: function(e) {
    gutil.beep();
    gutil.beep();
    return gutil.log(e);
  },
  htmlMinify: function(source) {
    return source.replace(/<!--([\s\S]*?)-->/g, '').replace(/\/\*([\s\S]*?)\*\//g, '').replace(/^\s+$/g, '').replace(/\n/g, '').replace(/\t/g, '').replace(/\r/g, '').replace(/\n\s+/g, ' ').replace(/\s+/g, ' ').replace(/>([\n\s+]*?)</g, '><');
  }
};


/*
 * js 生产文件处理函数
 * @param {string} files 接收一个路径参数，同gulp.src
 * @param {function} cb 处理过程中，处理一个buffer流的回调
 * @param {function} cb2 所有buffer处理完成后的回调函数
 */

_paths = {};

jsCtl = (function() {
  function jsCtl() {
    this.combo = bind(this.combo, this);
    this.init = bind(this.init, this);
  }

  jsCtl.prototype._jsPath = setting.jsPath;

  jsCtl.prototype._distPath = setting.distPath;

  jsCtl.prototype.amdReg = /define\s*\(([^(]*),?\s*?function\s*\([^\)]*\)\s*\{/;

  jsCtl.prototype.expStr = /define\s*\(([^(]*),?\s*?function/;

  jsCtl.prototype.depArrReg = /^[^\[]*(\[[^\]\[]*\]).*$/;

  jsCtl.prototype.filter = ['less', 'tpl', 'vendor'];

  jsCtl.prototype.tryEval = function(str) {
    var err, json;
    try {
      return json = eval('(' + str + ')');
    } catch (_error) {
      err = _error;
    }
  };

  jsCtl.prototype.filterDepMap = function(depMap) {
    var arr, filter, i, key, len;
    arr = [];
    filter = ["require", "exports", "module", ""];
    for (i = 0, len = depMap.length; i < len; i++) {
      key = depMap[i];
      if (indexOf.call(filter, key) < 0) {
        arr.push(key);
      }
    }
    return arr;
  };

  jsCtl.prototype.madeModId = function(filepath) {
    return filepath.replace(/\\/g, '/').split('/_src/')[1].replace(/.js$/, '');
  };

  jsCtl.prototype.madeModList = function(depArr, curPath) {
    var _arr, _filePath, _val, i, len, val;
    _arr = [];
    if (depArr.length > 0) {
      for (i = 0, len = depArr.length; i < len; i++) {
        val = depArr[i];
        _val = val;
        if (_val.indexOf('../') === 0 || _val.indexOf('./') === 0) {
          _filePath = path.join(curPath, _val);
          _val = this.madeModId(_filePath);
        }
        _arr.push(_val);
      }
    }
    return _arr;
  };

  jsCtl.prototype.arrToString = function(arr) {
    var _str;
    _str = "";
    if (arr.length > 0) {
      _.forEach(arr, function(val, n) {
        return _str += (n > 0 ? "," : "") + ("'" + val + "'");
      });
    }
    return "[" + _str + "]";
  };

  jsCtl.prototype._stream = function(files, cb, cb2) {
    var _this;
    _this = this;
    return gulp.src([files]).pipe(plumber({
      errorHandler: Tools.errrHandler
    })).on('data', function(source) {
      var _filePath, _list, _modId, _nameObj, _source;
      _list = [];
      _filePath = source.path.replace(/\\/g, '/');
      _nameObj = path.parse(_filePath);
      _modId = _this.madeModId(_filePath);
      _source = String(source.contents);
      if (_filePath.indexOf("/vendor/") === -1) {
        _source = _source.replace(_this.amdReg, function(str, map) {
          var _arr, _depStr, _str, error;
          _depStr = map.replace(_this.depArrReg, "$1");
          if (/^\[/.test(_depStr)) {
            _arr = _this.tryEval(_depStr);
            try {
              _arr = _this.filterDepMap(_arr);
              _list = _this.madeModList(_arr, _nameObj.dir);
              _str = _this.arrToString(_list);
              return str.replace(_this.expStr, "define('" + _modId + "'," + _str + ",function");
            } catch (_error) {
              error = _error;
            }
          } else {
            return str.replace(_this.expStr, "define('" + _modId + "',function");
          }
        });
      }
      return cb(_nameObj, _source);
    }).on('end', cb2);
  };

  jsCtl.prototype._buildJs = function(name, source) {
    var _file;
    _file = path.join(this._distPath, name);
    Tools.mkdirsSync(path.dirname(_file));
    return fs.writeFileSync(_file, source, 'utf8');
  };


  /*
   * Build AMDmodule with ID
   * @param {string} file 同gulp.src接口所接收的参数，默认是js debug目录中的所有js文件
   * @param {function} done 回调函数
   */

  jsCtl.prototype.init = function(file, done) {
    var _done, _file, _num, _this;
    gutil.log("Build js...");
    if (typeof file === 'function') {
      _done = file;
      _file = this._jsPath + '**/*.js';
    } else {
      _file = file || this._jsPath + '**/*.js';
      _done = done || function() {};
    }
    _this = this;
    _num = 0;
    return this._stream(_file, function(obj, source) {
      var _dir, _distname, _source;
      _paths[obj.name] = "dist/" + obj.name;
      _source = source;
      _dir = obj.dir.split("/_src/")[1];
      _distname = obj.name + obj.ext;
      _dir && (_distname = _dir + '/' + _distname);
      if (_num % 20 === 0 && _num > 15) {
        gutil.log('Building...');
      }
      _this._buildJs(_distname, _source);
      return _num++;
    }, function() {
      gutil.log('Build success!');
      return _done();
    });
  };

  jsCtl.prototype.combo = function(cb) {
    var _baseUrl, _main, _outName;
    _baseUrl = './';
    _main = "_src/" + pkg.name + ".js";
    _outName = pkg.name + ".js";
    return rjs({
      baseUrl: _baseUrl,
      name: _main,
      out: _outName
    }).on('data', function(output) {
      var _source;
      return _source = String(output.contents);
    }).pipe(gulp.dest('./dist/')).pipe(uglify()).pipe(rename({
      suffix: ".min",
      extname: ".js"
    })).pipe(gulp.dest('./dist/')).on('end', function() {
      return cb && cb();
    });
  };

  return jsCtl;

})();

build = {
  init: function() {
    var _dir, _jsData, _mainFile, i, init_dir, len;
    init_dir = [setting.lessPath, setting.jsPath, setting.imgPath, setting.tplPath];
    for (i = 0, len = init_dir.length; i < len; i++) {
      _dir = init_dir[i];
      Tools.mkdirsSync(_dir);
      gutil.log(_dir + " made success!");
    }
    _mainFile = path.join(setting.jsPath, _modName + '.js');
    if (!fs.existsSync(_mainFile)) {
      _jsData = "define(function(){\n\tvar Lib = window.Lib || (window.Lib = {});\n\t/*code here*/\n\t\n\tLib." + _modName + "=" + _modName + ";\n\treturn Lib;\n});";
      fs.writeFileSync(_mainFile, _jsData, 'utf8');
    }
    return gutil.log(color.cyan(_modName + " init success!"));
  },
  paths: function(obj) {
    var _Data;
    _Data = JSON.stringify(obj, null, 2);
    fs.writeFileSync(path.join(setting.distPath, "paths.json"), _Data, 'utf8');
    return gutil.log('paths.json done!');
  },
  cfg: function(obj) {
    var _distPath, config, jsPaths, jsSrcPath, key, myPaths, newPaths, rCfg, require_cfg, shimData, val;
    config = require('../config.json');
    _distPath = setting.distPath;
    myPaths = obj || require('../dist/paths.json');
    shimData = config.shim;
    jsPaths = config.paths;
    newPaths = {};
    for (key in jsPaths) {
      val = jsPaths[key];
      if (key !== 'require') {
        newPaths[key] = val;
      }
    }
    rCfg = {
      baseUrl: './',
      paths: _.assign(newPaths, myPaths),
      shim: shimData
    };
    jsSrcPath = config.jsSrcPath;
    require_cfg = "require.config(" + (JSON.stringify(rCfg, null, 2)) + ");";
    fs.writeFileSync(path.join('.', "require_cfg.js"), require_cfg, 'utf8');
    return gutil.log('require_cfg.js done!');
  },
  less2js: function(cb) {
    var _files, _less, _lessPath;
    _lessPath = setting.lessPath;
    _less = function(lessFile, cb) {
      var _source;
      _source = {};
      return gulp.src(lessFile).pipe(plumber({
        errorHandler: Tools.errHandler
      })).pipe(less({
        compress: false
      })).pipe(mincss({
        keepBreaks: false,
        compatibility: {
          properties: {
            iePrefixHack: true,
            ieSuffixHack: true
          }
        }
      })).pipe(gulp.dest(setting.distPath + "css")).on('data', function(output) {
        var _contents, _fileName, cssBgReg;
        _fileName = path.basename(output.path, '.css');
        _contents = output.contents.toString();
        cssBgReg = /url\s*\(([^\)]+)\)/g;
        _contents = _contents.replace(cssBgReg, function(str, map) {
          var key, val;
          if (map.indexOf('fonts/') !== -1 || map.indexOf('font/') !== -1 || map.indexOf('#') !== -1) {
            return str;
          } else {
            key = map.replace(/(^\'|\")|(\'|\"$)/g, '');
            console.log(key);
            val = map.indexOf('data:') > -1 || map.indexOf('about:') > -1 ? map : key + '?=t' + String(new Date().getTime()).substr(0, 8);
            console.log(val);
            return str.replace(map, val);
          }
        });
        return _source[_fileName] = _contents;
      }).on('end', function() {
        return cb && cb(_source);
      });
    };
    _files = [];
    fs.readdirSync(_lessPath).forEach(function(f) {
      var _lessFile;
      if (f.indexOf('.') !== 0 && f.indexOf('.less') !== -1) {
        _lessFile = path.join(_lessPath, f);
        return _files.push(_lessFile);
      }
    });
    return _less(_files, function(datas) {
      var css_source;
      css_source = "define(function(){var Lib=window.Lib||(window.Lib={});Lib." + _modName + "Css = " + (JSON.stringify(datas)) + ";return Lib;});";
      fs.writeFileSync(path.join(setting.jsPath, _modName + "Css.js"), css_source, 'utf8');
      gutil.log('lessToCss done!');
      return cb && cb();
    });
  },
  tpl2js: function(cb) {
    var _htmlMinify, _tplPath, tplData, tpl_soure;
    _htmlMinify = Tools.htmlMinify;
    _tplPath = setting.tplPath;
    tplData = {};
    fs.readdirSync(_tplPath).forEach(function(file) {
      var _fileName, _file_path, _source, file_source;
      _file_path = path.join(_tplPath, file);
      if (fs.statSync(_file_path).isFile() && file.indexOf('.html') !== -1 && file.indexOf('.') !== 0) {
        _fileName = path.basename(file, '.html');
        _source = fs.readFileSync(_file_path, 'utf8');
        file_source = Tools.htmlMinify(_source);
        if (file.indexOf('_') === 0) {
          return tplData[_fileName] = "<script id=\"tpl" + _fileName + "\" type=\"text/html\">" + file_source + "</script>";
        } else {
          return tplData[_fileName] = file_source;
        }
      }
    });
    tpl_soure = "define(function(){var Lib=window.Lib||(window.Lib={});Lib." + _modName + "Tpl = " + (JSON.stringify(tplData)) + ";return Lib;});";
    fs.writeFileSync(path.join(setting.jsPath, _modName + "Tpl.js"), tpl_soure, 'utf8');
    gutil.log('tplTojs done!');
    return cb && cb();
  },
  img2dist: function(cb) {
    var _cb, _imgPath, _this;
    _this = this;
    _cb = cb || function() {};
    _imgPath = setting.imgPath;
    return gulp.src(_imgPath + '*.*').pipe(gulp.dest(setting.distPath + 'img')).on("end", function() {
      return _cb();
    });
  },
  js2dist: function(cb) {
    var _cb, _this;
    _this = this;
    _cb = cb || function() {};
    return new jsCtl().init(function() {
      _this.paths(_paths);
      _this.cfg(_paths);
      return _cb();
    });
  },
  _getType: function(dir) {
    var type;
    type = '';
    if (dir.indexOf('_tpl') > 0) {
      type = 'tpl';
    } else if (dir.indexOf('_less') > 0) {
      type = 'less';
    } else {
      type = 'js';
    }
    return type;
  },
  watch: function() {
    var _list, _this, _watchFiles;
    _this = this;
    _list = [];
    _watchFiles = setting.watchFiles;
    return watch(_watchFiles, function(file) {
      var _event, _file_path, _parse, _type, err, watch_timer;
      try {
        _event = file.event;
        if (_event !== 'undefined') {
          _file_path = file.path.replace(/\\/g, '/');
          _parse = path.parse(_file_path);
          _type = _this._getType(_parse.dir);
          if (indexOf.call(_type, _type) < 0) {
            _list.push(_type);
          }
          switch (_type) {
            case 'js':
              new jsCtl().init();
              break;
            case 'less':
              _this.less2js();
              break;
            case 'tpl':
              _this.tpl2js();
          }
        }
        if (watch_timer) {
          clearTimeout(watch_timer);
        }
        return watch_timer = setTimeout(function() {
          return _list = [];
        }, 3000);
      } catch (_error) {
        err = _error;
        return console.log(err);
      }
    });
  },
  server: function() {
    var appPath;
    appPath = setting.root;
    return gulp.src(appPath).pipe(server({
      livereload: false,
      directoryListing: true,
      open: true,
      host: 'localhost',
      port: 8800
    }));
  }
};

exports.setting = setting;

exports.build = build;
